classdef fun
    
    methods (Static)
        
        function v = quadratic(x,par)
           v = (1/2)*x'*par.P*x + par.q'*x + par.r;
        end
        
        function g = quadratic_grad(x,par)
           g = par.P*x + par.q;
        end
        
        function h = quadratic_hess(x,par)
           h = par.P;
        end
        
        function v = LogVolume(z,par)
            cov=0;
            for i=1:par.m
                cov=cov+z(i)*(par.a(:,i)*par.a(:,i)');
            end
            
            v = log(det(cov));
        end
        
        function cov = cov(z,par)
            cov=zeros(size(par.a,1),size(par.a,1));
            for i=1:par.m
                cov=cov+z(i)*(par.a(:,i)*par.a(:,i)');
            end
        end
        
        function v = ApproxLogVolume(z,par)
            cov=fun.cov(z,par);
            
            if (max(z,[],1)>1) || (min(z,[],1)<0)
                v=-10e6;
            else
            v = log(det(cov)) ...
              + par.kappa*sum(log(z) + log(1-z),1);
            end
        end            
        
        function g = ApproxLogVolume_grad(z,par)
            cov=fun.cov(z,par);
            L = chol(cov,'upper'); % Cholesky factoriazation;
            
            g=NaN(par.m,1);
            for i=1:par.m
                g(i) = par.a(:,i)'*(L\(L'\par.a(:,i))) ... 
                     + par.kappa/z(i) - par.kappa/(1-z(i));
            end
            
        end
        
        function h = ApproxLogVolume_hess(z,par)
            cov=fun.cov(z,par);
            L = chol(cov,'upper'); % Cholesky factoriazation;
            aL = L'\par.a;
            
            d = (1./(z.*z)) + (1./((1-z).*(1-z)));
            aWa = aL'*aL;
            
            h = - aWa.*aWa - par.kappa*diag(d);
            
        end
        
        function out1 = h1(psx,psy,ptx,pty,ts)
        %    OUT1 = H1(PSX,PSY,PTX,PTY,TS)

        %    This function was generated by the Symbolic Math Toolbox version 7.2.
        %    24-Jun-2019 09:59:38

        t2 = cos(ts);
        t3 = psy-pty;
        t4 = sin(ts);
        t5 = psx-ptx;
        t11 = t2.*t3;
        t12 = t4.*t5;
        t6 = t11-t12;
        t7 = t2.*t5;
        t8 = t3.*t4;
        t9 = t7+t8;
        t10 = 1.0./t9.^2;
        out1 = (t4./t9+t2.*t6.*t10)./(t6.^2.*t10+1.0);
        end
        
        function out1 = h2(psx,psy,ptx,pty,ts)
        %    OUT1 = H2(PSX,PSY,PTX,PTY,TS)

        %    This function was generated by the Symbolic Math Toolbox version 7.2.
        %    24-Jun-2019 09:59:39

        t2 = cos(ts);
        t3 = psy-pty;
        t4 = sin(ts);
        t5 = psx-ptx;
        t11 = t2.*t3;
        t12 = t4.*t5;
        t6 = t11-t12;
        t7 = t2.*t5;
        t8 = t3.*t4;
        t9 = t7+t8;
        t10 = 1.0./t9.^2;
        out1 = -(t2./t9-t4.*t6.*t10)./(t6.^2.*t10+1.0);
        end
        
    end
end

